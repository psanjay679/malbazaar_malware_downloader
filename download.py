import requests
import json
import os
from multiprocessing.pool import ThreadPool as Pool
import sys
import logging
global sign_hash_list
global hash_pool


logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s %(levelname)-8s %(message)s',
                    datefmt='%m-%d %H:%M',
                    filename='download.log',
                    filemode='w')


url = 'https://mb-api.abuse.ch/api/v1/'


def get_signature_info(signature_name='trickBot', limit=100):

    post_data = {
        'query': 'get_taginfo',
        'tag': signature_name,
        'limit': limit
    }

    result = requests.post(url, data=post_data)
    return json.loads(result.text)


def get_hashes_from_signature(signature_name='trickBot', limit=100):

    global sign_hash_list
    logging.info(f'getting info for: {signature_name}')

    signature_info = get_signature_info(signature_name=signature_name, limit=limit)

    result = list()

    if signature_info['query_status'] == 'ok':
        result = [(x.get('sha1_hash'), x.get('file_name')) for x in signature_info['data']]

    download_pool = Pool(len(result))

    for file_hash, file_name in result:
        download_pool.apply_async(download_malware_sample, (file_hash, file_name, signature_name,))

    download_pool.close()
    download_pool.join()

    sign_hash_list.append({f'{signature_name}': result})


def download_malware_sample(file_hash, file_name, signature_name):

    file_name = '_'.join(file_name.split())

    download_dir = os.path.join(os.getcwd(), f'{signature_name}')

    if not os.path.exists(download_dir):
        os.mkdir(download_dir)
    
    file_path = os.path.join(download_dir, f'{file_name}.zip')

    if not os.path.exists(file_path):

        logging.info(f'download for signature: {signature_name} with filename: {file_name} starting...\n')

        post_data = {
            'query': 'get_file',
            'sha256_hash': file_hash
        }

        result = requests.post(url, data=post_data)

        with open(file_path, 'wb') as f:
            f.write(result.content)

        logging.info(f'download for signature: {signature_name} with filename: {file_name} is completed.\n')
    else:
        logging.info(f'{file_name} is alrady present.\n')


if __name__ == '__main__':

    global sign_hash_list

    # signatures = ['trickBot', 'dridex', 'quakbot']

    if len(sys.argv) < 2:
        print(f'usage: python download.py <list of comma seperated tags> <download file limit>')
        sys.exit()

    signatures = sys.argv[1].split(',')

    if len(sys.argv) == 3:
        limit = int(sys.argv[2])
    else:
        limit = 10
    
    pool = Pool(len(signatures))
    sign_hash_list = list()

    for signature in signatures:
        pool.apply_async(get_hashes_from_signature, (signature.lower(), limit))

    pool.close()
    pool.join()
